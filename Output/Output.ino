#include <SPI.h>
#include <mcp2515.h>

struct can_frame canMsg1;
struct can_frame canMsg2;
MCP2515 mcp2515(10);

#define NUM_MESSAGES 40

/*first dimension is each module. 2nd dimension is the can
 * frame in the form:
 * [id, size, b0, b1, b2, b3, b4, b5, b6, b7]
 * 
 * ex: 0x611, 8, 00,30,3E,3E,3E,3D,3D,FF,
*/
int data[NUM_MESSAGES][10] = {
{0x611,8,0x00,0x30,0x3E,0x3E,0x3E,0x3D,0x3D,0xFF},
{0x612,8,0x0F,0x79,0x0F,0x76,0x0F,0x78,0x0F,0x79},
{0x613,8,0x0F,0x78,0x0F,0x78,0x0F,0x78,0x0F,0x6F},
{0x614,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x621,8,0x00,0x30,0x3D,0x3D,0x3E,0x3E,0x3E,0xFF},
{0x622,8,0x0F,0x78,0x0F,0x78,0x0F,0x78,0x0F,0x78},
{0x623,8,0x0F,0x78,0x0F,0x79,0x0F,0x78,0x0F,0x78},
{0x624,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x631,8,0x00,0x30,0x3A,0x3A,0x3A,0x3A,0x3B,0xFF},
{0x632,8,0x0F,0x76,0x0F,0x76,0x0F,0x78,0x0F,0x78},
{0x633,8,0x0F,0x76,0x0F,0x78,0x0F,0x78,0x0F,0x75},
{0x634,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x641,8,0x00,0x30,0x3B,0x3B,0x3A,0x3A,0x3A,0xFF},
{0x642,8,0x0F,0x76,0x0F,0x75,0x0F,0x78,0x0F,0x76},
{0x643,8,0x0F,0x76,0x0F,0x76,0x0F,0x78,0x0F,0x78},
{0x644,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x651,8,0x00,0x30,0x3A,0x3A,0x3A,0x3A,0x3B,0xFF},
{0x652,8,0x0F,0x76,0x0F,0x78,0x0F,0x76,0x0F,0x78},
{0x653,8,0x0F,0x78,0x0F,0x76,0x0F,0x76,0x0F,0x75},
{0x654,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x671,8,0x00,0x30,0x3B,0x3A,0x3A,0x3A,0x3A,0xFF},
{0x672,8,0x0F,0x73,0x0F,0x75,0x0F,0x76,0x0F,0x78},
{0x673,8,0x0F,0x75,0x0F,0x75,0x0F,0x75,0x0F,0x76},
{0x674,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x681,8,0x00,0x30,0x3A,0x3A,0x3A,0x3A,0x3A,0xFF},
{0x682,8,0x0F,0x76,0x0F,0x76,0x0F,0x78,0x0F,0x76},
{0x683,8,0x0F,0x75,0x0F,0x76,0x0F,0x76,0x0F,0x75},
{0x684,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x691,8,0x00,0x30,0x3B,0x3A,0x3A,0x3A,0x3A,0xFF},
{0x692,8,0x0F,0x78,0x0F,0x76,0x0F,0x78,0x0F,0x78},
{0x693,8,0x0F,0x78,0x0F,0x78,0x0F,0x78,0x0F,0x78},
{0x694,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x6A1,8,0x00,0x30,0x3E,0x3E,0x3E,0x3D,0x3D,0xFF},
{0x6A2,8,0x0F,0x78,0x0F,0x76,0x0F,0x76,0x0F,0x78},
{0x6A3,8,0x0F,0x78,0x0F,0x78,0x0F,0x76,0x0F,0x76},
{0x6A4,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
{0x6B1,8,0x00,0x30,0x3D,0x3E,0x3E,0x3F,0x3F,0xFF},
{0x6B2,8,0x0F,0x72,0x0F,0x75,0x0F,0x75,0x0F,0x75},
{0x6B3,8,0x0F,0x75,0x0F,0x73,0x0F,0x73,0x0F,0x76},
{0x6B4,8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}};

void setup() {
  
  while (!Serial);
  Serial.begin(115200);
  
  mcp2515.reset();
  //NANO can send at 8mhz
  //UNO can send at 16mhz
  mcp2515.setBitrate(CAN_500KBPS, MCP_8MHZ);
  mcp2515.setNormalMode();
  
  Serial.println("Example: Write to CAN");
}

void loop() {
  

  for (int i=0; i<NUM_MESSAGES; i++){
      can_frame canMsg;
      canMsg.can_id  = data[i][0];
      canMsg.can_dlc = data[i][1];
      canMsg.data[0] = data[i][2];
      canMsg.data[1] = data[i][3];
      canMsg.data[2] = data[i][4];
      canMsg.data[3] = data[i][5];
      canMsg.data[4] = data[i][6];
      canMsg.data[5] = data[i][7];
      canMsg.data[6] = data[i][8];
      canMsg.data[7] = data[i][9];
      int status1 = mcp2515.sendMessage(&canMsg);
  }

  /*int status1 = mcp2515.sendMessage(&canMsg1);
  
  Serial.println("Messages sent");
  Serial.print(status1);
  Serial.println("");*/
  delay(100);
}
